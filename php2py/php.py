from collections import OrderedDict
import os.path
import urllib.parse
import sys

from .exceptions import *
from phpbaselib import filters


class PhpVars(object):
    def __getattr__(self, name):
        """ Apparently getattr is called after first searching to see if there is already an attribute attr

        I think we have to do this because php eats undefined variables for breakfast

        """
        return None


class PhpFunctions(PhpVars):
    def __init__(self):
        for fname, f in phpfunctions.functionlist:
            setattr(self, fname, f)


class PhpGlobals(PhpVars):
    def __init__(self):
        # Sets the super-global variables
        # $_POST etc
        self._SERVER = {}
        self._GET = {}
        pass


class PhpClasses(PhpVars):
    def __init__(self):
        self.PhpBase = PhpBase


class PhpBase(object):
    """ The base class for all "php" classes"

    """
    def __init__(self, *args, **kwargs):
        self._php_construct(*args, **kwargs)

    def _php_construct(self, *args, **kwargs):
        """ _-construct is the php version of __init__

        """
        pass


class PhpConstants(PhpVars):
    def __init__(self):
        self.DIRECTORY_SEPARATOR = os.path.sep

        # Error reporting constants
        # TODO: Maybe we should just always be something like E_ALL...
        self.E_ERROR            = 1    # Fatal errors. Exit
        self.E_WARNING          = 2    # Run time errors. Don't exit
        self.E_PARSE            = 4    # Parse errors.
        self.E_NOTICE           = 8    # Run time notices. Might or might not be an actual error
        self.E_CORE_ERROR       = 16   # Errors on startup in the core
        self.E_CORE_WARNING     = 32   # Errors at startup which aren't fatal
        self.E_COMPILE_ERROR    = 64   # Fatal compile time errors
        self.E_COMPILE_WARNING  = 128  # Compile time non fatal errors
        self.E_USER_ERROR       = 256  # Fatal user error generated by trigger_error function
        self.E_USER_WARNING     = 512  # Not fatal...
        self.E_USER_NOTICE      = 1024 # Just a notice
        self.E_STRICT           = 2048 # Enables suggestions from php engine
        self.E_RECOVERABLE_ERROR= 4096 # Probably dangerous? Like an exception I think
        self.E_DEPRECATED       = 8192 # Indicated deprecated functionality at run time
        self.E_USER_DEPRECATED  = 16384
        self.E_ALL              = 32797 # All errors and warnings

        self.FILTER_SANITIZE_URL = filters.filter_sanitize_url


class PhpApp(object):
    """ The inner application to be eventually served up.

    Attributes:
        body: A callable function that will return the body of the response
        headers: A list of headers to be returned
        response_code: The http response code to use. Defaults to 500
        response_message: The http message to include along with the response code
        f: All the functions defined in the php engine and by translated php code
        c: All the classes defined in the php engine and by translated php code
        i: A dict containing information about what has already been imported
        # TODO: Is this actually used any more


    """
    def __init__(self):
        self.body = None
        self.body_str = ""
        self._headers = OrderedDict()
        self.response_code = 500
        self.response_msg = "Server Error"

        # The php engine runs on these variables
        self.g = PhpGlobals()
        self.constants = PhpConstants()
        self.f = None
        self.c = PhpClasses()
        self.i = {}
        self.script_name = None
        self.error_level = self.constants.E_ALL
        self.ini = {}

    def __call__(self, environ, start_response):
        # TODO: This isn't thread safe at all
        # TODO: it probably isn't even cross request safe
        self.initialize_environ(environ)
        import pprint
        pprint.pprint(environ)
        self.body()
        # If body didn't change the response code, we must be ok
        if self.response_code == 500:
            self.response_code = 200
            self.response_msg = "OK"
        status = "{} {}".format(self.response_code, self.response_msg)
        headers = list(self.headers.items())
        start_response(status, headers)
        # should this be bytes?
        return [self.body_str.encode("utf-8")]

    def initialize_environ(self, environ):
        self.g.__init__()
        self.constants.__init__()
        self.f.__init__()
        self.c.__init__()
        self.i = {}
        self.body_str = ""

        self.g._SERVER["HTTP_HOST"] = environ["HTTP_HOST"]
        # TODO: Get this from wsgi server somehow
        # TODO: This is a hack to get things working. I think I'll need to use a full routing library in future
        self.g._SERVER["SCRIPT_NAME"] = "//" # os.path.relpath(self.script_name).replace("\\", "/")
        get = self.g._GET
        get["url"] = environ["PATH_INFO"]
        queries = urllib.parse.parse_qs(environ["QUERY_STRING"])
        get.update(queries)

    def init_console(self, body, script_name):
        self.init_http(body, script_name)
        # overrides
        # root_dir = os.path.abspath(os.path.dirname(script_name))
        self.g._SERVER["HTTP_HOST"] = ''
        self.g._SERVER["SCRIPT_NAME"] = os.path.relpath(script_name).replace("\\", "/")

    def init_http(self, body, script_name):
        """ Initialise the app

        Args:
            body: A callable which return a string for the body
            root_dir: The main script this app is being served from

        """
        # HTTP
        self.body = body

        # Helpers for php engine
        self.script_name = script_name


    # TODO: You are doing this wrong?
    @property
    def headers(self):
        return self._headers

    def add_header(self, name, value):
        """ Add  a new header to be output when used as a wsgi app

        Params:
            name: The name of the header to add
            value: The value the header should take

        This function will add additional  headers of the same name

        """
        if name in self._headers:
            self.headers[name].append(value)
        else:
            self.headers[name] = [value]

    def replace_header(self, name, value):
        """ Add  a new header to be output when used as a wsgi app

        Params:
            name: The name of the header to add
            value: The value the header should take

        This function will replace any existing headers called name

        """
        self.headers[name] = [value]

    def console_response(self):
        # TODO: Should we allow interactive use here?
        self.body()
        return self.body_str.encode('utf-8')

    def write(self, item):
        # Write the item as a string to the body string
        # TODO: Build the body string much more nicely. Think about making a phpfunction called echo instead
        self.body_str += str(item)


# Using the module import to create a kind of singleton
_app_ = PhpApp()
_c_ = _app_.c
_g_ = _app_.g
_constants_ = _app_.constants

# Need to define singletons before we can import things that use them
from . import phpfunctions
_app_.f = PhpFunctions()
_f_ = _app_.f
